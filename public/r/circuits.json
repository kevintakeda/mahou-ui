{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "circuits",
  "type": "registry:ui",
  "dependencies": [
    "pixi.js",
    "@pixi/react",
    "pixi-filters"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/circuits.tsx",
      "content": "\"use client\";\nimport { useExtend, useTick } from \"@pixi/react\";\nimport {\n  Color,\n  type ColorSource,\n  Container,\n  FillGradient,\n  Graphics,\n  Sprite,\n} from \"pixi.js\";\nimport { BloomFilter } from \"pixi-filters\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n\ninterface ColorStop {\n  offset: number;\n  color: ColorSource;\n}\n\ninterface CircuitsProps {\n  speed?: number;\n  numPaths?: number;\n  stepY?: number;\n  stepX?: number;\n  stepJitterMax?: number;\n  stepJitterMin?: number;\n  steps?: number;\n  width?: number;\n  height?: number;\n  startX?: number;\n  startY?: number;\n  colorStops?: ColorStop[];\n  trailWidth?: number;\n  trailHeight?: number;\n  bloomStrength?: number;\n  bloomKernelSize?: number;\n  bloomQuality?: number;\n  loop?: boolean;\n  playing?: boolean;\n  onEnd?: () => void;\n}\n\nconst defaultColorStops: ColorStop[] = [\n  { offset: 0, color: new Color(0xff94fe).setAlpha(0) },\n  { offset: 1, color: new Color(0xd2ff65) },\n];\n\nexport function Circuits({\n  speed = 500,\n  numPaths = 16,\n  stepY = 16,\n  stepX = 16,\n  stepJitterMax = 128,\n  stepJitterMin = 64,\n  steps = 10,\n  width = 512,\n  height = 512,\n  colorStops = defaultColorStops,\n  trailWidth = 512,\n  trailHeight = 256,\n  bloomStrength = 16,\n  bloomKernelSize = 5,\n  bloomQuality = 10,\n  loop = true,\n  playing = true,\n  onEnd,\n}: CircuitsProps) {\n  useExtend({ Container, Sprite, Graphics });\n  const [animationVersion, setAnimationVersion] = useState(0);\n  const finishedCounter = useRef(0);\n\n  const onFinish = useCallback(() => {\n    finishedCounter.current++;\n    if (finishedCounter.current >= numPaths) {\n      finishedCounter.current = 0;\n      onEnd?.();\n      if (loop) {\n        setAnimationVersion((v) => v + 1);\n      }\n    }\n  }, [numPaths, loop, onEnd]);\n\n  const gradient = useMemo(\n    () =>\n      new FillGradient({\n        end: { x: 0, y: 1 },\n        colorStops,\n      }),\n    [colorStops],\n  );\n\n  const filters = useMemo(\n    () => [\n      new BloomFilter({\n        strength: bloomStrength,\n        kernelSize: bloomKernelSize,\n        quality: bloomQuality,\n      }),\n    ],\n    [bloomStrength, bloomKernelSize, bloomQuality],\n  );\n  const circuitConfigs = useMemo(() => {\n    return Array.from({ length: numPaths }).map((_, i) => {\n      const centerIndex = (numPaths - 1) / 2;\n      const distance = Math.abs(i - centerIndex) / numPaths / 2;\n\n      const positionalSpeed = speed - Math.min(distance * 750, speed / 2);\n      const randomJitter = Math.random() * 100;\n      const finalSpeed = Math.max(100, positionalSpeed + randomJitter);\n      const optimalGap = stepX + stepX;\n\n      const totalSpan = (numPaths - 1) * optimalGap;\n      const offset = (width - totalSpan) / 2;\n      const x = offset + i * optimalGap;\n\n      return {\n        id: i,\n        speed: finalSpeed,\n        startX: x,\n      };\n    });\n  }, [numPaths, speed, stepX, width]);\n\n  return (\n    <pixiContainer width={width} height={height} filters={filters}>\n      {circuitConfigs.map((config) => (\n        <SingleCircuit\n          key={config.id}\n          speed={config.speed}\n          stepY={stepY}\n          stepX={stepX}\n          stepJitterMax={stepJitterMax}\n          stepJitterMin={stepJitterMin}\n          steps={steps}\n          startX={config.startX}\n          startY={0}\n          trailWidth={trailWidth}\n          trailHeight={trailHeight}\n          height={height}\n          gradient={gradient}\n          onFinish={onFinish}\n          animationVersion={animationVersion}\n          playing={playing}\n        />\n      ))}\n    </pixiContainer>\n  );\n}\n\nfunction SingleCircuit({\n  speed,\n  stepY,\n  stepX,\n  stepJitterMax,\n  stepJitterMin,\n  steps,\n  startX,\n  startY,\n  trailWidth,\n  trailHeight,\n  height,\n  gradient,\n  onFinish,\n  animationVersion,\n  playing,\n}: {\n  speed: number;\n  stepY: number;\n  stepX: number;\n  stepJitterMax: number;\n  stepJitterMin: number;\n  steps: number;\n  startX: number;\n  startY: number;\n  trailWidth: number;\n  trailHeight: number;\n  height?: number;\n  gradient: FillGradient;\n  onFinish: () => void;\n  animationVersion: number;\n  playing: boolean;\n}) {\n  const maskRef = useRef<Graphics>(null);\n  const gradientRef = useRef<Graphics>(null);\n\n  const drawMask = useCallback(\n    (g: Graphics) => {\n      g.clear();\n      let x = startX,\n        y = startY;\n\n      g.moveTo(x, y);\n      let dir = Math.random() > 0.5 ? 1 : -1;\n      let alt = -1;\n\n      for (let j = 0; j < steps; j++) {\n        if (alt === -1) {\n          alt = 1;\n          y += stepY + Math.random() * stepJitterMax + stepJitterMin;\n          g.lineTo(x, y);\n        } else {\n          alt = -1;\n          dir *= -1;\n          x = x + stepX * dir;\n          y = y + stepY;\n          g.lineTo(x, y);\n        }\n      }\n      g.stroke({ color: 0x00ff00, width: 1, pixelLine: true });\n    },\n    [stepJitterMax, stepJitterMin, stepX, stepY, steps, startX, startY],\n  );\n\n  const drawGradient = useCallback(\n    (g: Graphics) => {\n      g.clear();\n      g.rect(0, 0, trailWidth, trailHeight);\n      g.fill(gradient);\n    },\n    [gradient, trailWidth, trailHeight],\n  );\n\n  const delayCounterRef = useRef(0);\n  const onFinishCalledRef = useRef(false);\n  const startYPos = -trailHeight - trailHeight * 0.5;\n\n  useEffect(() => {\n    if (maskRef.current && gradientRef.current) {\n      gradientRef.current.mask = maskRef.current;\n    }\n  }, []);\n\n  useEffect(() => {\n    if (animationVersion > 0) {\n      delayCounterRef.current = 0;\n    }\n    if (gradientRef.current) {\n      gradientRef.current.y = startYPos;\n    }\n    onFinishCalledRef.current = false;\n  }, [animationVersion, startYPos]);\n\n  useTick((ticker) => {\n    if (gradientRef.current && playing) {\n      if (onFinishCalledRef.current) {\n        return;\n      }\n\n      const speedInMs = speed / 1000;\n      gradientRef.current.y += speedInMs * ticker.deltaMS;\n\n      const containerHeight = height ?? 256;\n      const finishY = containerHeight + trailHeight / 2;\n\n      if (gradientRef.current.y >= finishY) {\n        onFinish();\n        onFinishCalledRef.current = true;\n      }\n    }\n  });\n\n  return (\n    <>\n      <pixiGraphics ref={maskRef} draw={drawMask} />\n      <pixiGraphics ref={gradientRef} draw={drawGradient} />\n    </>\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}