{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "flow",
  "type": "registry:ui",
  "dependencies": [
    "motion",
    "react-use-measure"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/flow.tsx",
      "content": "/** biome-ignore-all lint/a11y/noSvgWithoutTitle: svg used for decoration */\n\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { type RefObject, useEffect, useId, useRef, useState } from \"react\";\nimport useMeasure from \"react-use-measure\";\n\nexport interface FlowProps {\n  className?: string;\n  fromRef: RefObject<HTMLElement | null>;\n  toRef: RefObject<HTMLElement | null>;\n  borderRadius?: number;\n  spacing?: number;\n  glow?: number;\n  baseColor?: string;\n  flowColor: string;\n  style?: \"smooth\" | \"sharp\";\n}\n\nexport default function Flow({\n  fromRef,\n  toRef,\n  borderRadius = 48,\n  spacing: propSpacing,\n  glow = 0,\n  baseColor,\n  flowColor,\n  style = \"sharp\",\n}: FlowProps) {\n  const [data, setData] = useState<{\n    path: string;\n    width: number;\n    height: number;\n  } | null>(null);\n  const [svgRef, svgBounds] = useMeasure();\n  const pathRef = useRef<SVGPathElement>(null);\n  const effectiveSpacing = propSpacing ?? 200;\n  const filterId = useId();\n  const margin = glow * 6;\n\n  useEffect(() => {\n    const fromEl = fromRef.current;\n    const toEl = toRef.current;\n    if (!fromEl || !toEl || svgBounds.width === 0 || svgBounds.height === 0)\n      return;\n    const fromRect = fromEl.getBoundingClientRect();\n    const toRect = toEl.getBoundingClientRect();\n    const startX = fromRect.left - svgBounds.left + fromRect.width / 2;\n    const startY = fromRect.bottom - svgBounds.top;\n    const endX = toRect.left - svgBounds.left + toRect.width / 2;\n    const endY = toRect.top - svgBounds.top;\n    const path =\n      style === \"smooth\"\n        ? generateSimpleSmoothStepPath(startX, startY, endX, endY, borderRadius)\n        : generateSimpleCutOutStepPath(\n            startX,\n            startY,\n            endX,\n            endY,\n            borderRadius,\n          );\n    setData({\n      path,\n      width: svgBounds.width,\n      height: svgBounds.height,\n    });\n  }, [\n    fromRef,\n    toRef,\n    borderRadius,\n    svgBounds.left,\n    svgBounds.top,\n    svgBounds.width,\n    svgBounds.height,\n    style,\n  ]);\n\n  if (!data) {\n    return (\n      <svg\n        ref={svgRef}\n        className=\"pointer-events-none absolute inset-0 z-0 overflow-visible\"\n        width=\"100%\"\n        height=\"100%\"\n        viewBox=\"0 0 1 1\"\n        fill=\"none\"\n      />\n    );\n  }\n\n  return (\n    <svg\n      ref={svgRef}\n      className=\"pointer-events-none absolute inset-0 z-0 overflow-visible\"\n      width=\"100%\"\n      height=\"100%\"\n      viewBox={`0 0 ${data.width} ${data.height}`}\n      fill=\"none\"\n    >\n      {glow && (\n        <defs>\n          <filter\n            id={filterId}\n            filterUnits=\"userSpaceOnUse\"\n            x={-margin}\n            y={-margin}\n            width={data.width + 2 * margin}\n            height={data.height + 2 * margin}\n          >\n            <feGaussianBlur stdDeviation={glow} result=\"blur1\" />\n            <feGaussianBlur stdDeviation={glow * 2} result=\"blur2\" />\n            <feMerge>\n              <feMergeNode in=\"blur1\" />\n              <feMergeNode in=\"blur2\" />\n              <feMergeNode in=\"SourceGraphic\" />\n            </feMerge>\n          </filter>\n        </defs>\n      )}\n      {baseColor && (\n        <path\n          ref={pathRef}\n          d={data.path}\n          stroke={baseColor}\n          strokeWidth=\"1\"\n          strokeLinecap=\"round\"\n          strokeLinejoin=\"round\"\n        />\n      )}\n      <motion.path\n        d={data.path}\n        stroke={flowColor}\n        strokeWidth=\"1\"\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        fill=\"none\"\n        strokeDasharray={`${effectiveSpacing} ${effectiveSpacing}`}\n        initial={{ strokeDashoffset: 0 }}\n        animate={{ strokeDashoffset: -effectiveSpacing * 2 }}\n        transition={{\n          duration: 2,\n          ease: \"linear\",\n          repeat: Infinity,\n        }}\n        filter={glow ? `url(#${filterId})` : undefined}\n      />\n    </svg>\n  );\n}\n\nfunction generateSimpleSmoothStepPath(\n  sourceX: number,\n  sourceY: number,\n  targetX: number,\n  targetY: number,\n  borderRadius = 0,\n) {\n  const dx = targetX - sourceX;\n  const dy = targetY - sourceY;\n  const signX = Math.sign(dx);\n\n  if (dy <= 0 || signX === 0) {\n    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;\n  }\n\n  const centerY = (sourceY + targetY) / 2;\n  const r = Math.min(borderRadius, Math.abs(dx) / 2, dy / 2);\n\n  if (dy < 2 * r) {\n    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;\n  }\n\n  let path = `M ${sourceX} ${sourceY}`;\n  path += ` L ${sourceX} ${centerY - r}`;\n  path += ` Q ${sourceX} ${centerY} ${sourceX + signX * r} ${centerY}`;\n  path += ` L ${targetX - signX * r} ${centerY}`;\n  path += ` Q ${targetX} ${centerY} ${targetX} ${centerY + r}`;\n  path += ` L ${targetX} ${targetY}`;\n  return path;\n}\n\nfunction generateSimpleCutOutStepPath(\n  sourceX: number,\n  sourceY: number,\n  targetX: number,\n  targetY: number,\n  borderRadius = 0,\n) {\n  const dx = targetX - sourceX;\n  const dy = targetY - sourceY;\n  const signX = Math.sign(dx);\n\n  if (dy <= 0 || signX === 0) {\n    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;\n  }\n\n  const centerY = (sourceY + targetY) / 2;\n  const r = Math.min(borderRadius, Math.abs(dx) / 2, dy / 2);\n\n  if (dy < 2 * r) {\n    return `M ${sourceX} ${sourceY} L ${targetX} ${targetY}`;\n  }\n\n  let path = `M ${sourceX} ${sourceY}`;\n  path += ` L ${sourceX} ${centerY - r}`;\n  path += ` L ${sourceX + signX * r} ${centerY}`;\n  path += ` L ${targetX - signX * r} ${centerY}`;\n  path += ` L ${targetX} ${centerY + r}`;\n  path += ` L ${targetX} ${targetY}`;\n  return path;\n}\n",
      "type": "registry:ui"
    }
  ]
}