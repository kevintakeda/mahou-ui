{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "grid-particles",
  "type": "registry:ui",
  "dependencies": [
    "pixi.js",
    "@pixi/react",
    "simplex-noise"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/grid-particles.tsx",
      "content": "\"use client\";\n\nimport { useApplication, useExtend, useTick } from \"@pixi/react\";\nimport {\n  Container,\n  Graphics,\n  Sprite,\n  type Texture,\n  type TickerCallback,\n} from \"pixi.js\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { createNoise2D } from \"simplex-noise\";\n\nexport interface EllipseMask {\n  radiusX: number;\n  radiusY: number;\n  invert?: boolean;\n}\n\nexport interface GridParticlesProps {\n  cellSize?: number;\n  minAlpha?: number;\n  maxAlpha?: number;\n  color?: number;\n  minSpeed?: number;\n  maxSpeed?: number;\n  size?: number;\n  frequency?: number;\n  threshold?: number;\n  fitToContainer?: boolean;\n  mode?:\n    | \"random\"\n    | \"top-to-bottom\"\n    | \"bottom-to-top\"\n    | \"left-to-right\"\n    | \"right-to-left\"\n    | \"center-outward\";\n  randomFn?: () => number;\n  ellipseMask?: EllipseMask;\n}\n\nexport function GridParticles({\n  cellSize = 24,\n  minAlpha = 0,\n  maxAlpha = 1,\n  color = 0xd2ff65,\n  minSpeed = 0.001,\n  maxSpeed = 0.002,\n  size = 2,\n  frequency = 3,\n  threshold = 0.4,\n  fitToContainer = true,\n  mode = \"random\",\n  randomFn = Math.random,\n  ellipseMask,\n}: GridParticlesProps) {\n  useExtend({ Container, Sprite, Graphics });\n  const { app, isInitialised } = useApplication();\n  const timeRef = useRef(0);\n  const containerRef = useRef<Container>(null);\n  const prevTextureRef = useRef<Texture>(null);\n\n  const dotTexture = useMemo(() => {\n    if (!isInitialised) return null;\n    const g = new Graphics();\n    g.rect(0, 0, size, size).fill({ color });\n    if (prevTextureRef.current != null) {\n      prevTextureRef.current.destroy();\n    }\n    const texture = app.renderer.generateTexture(g);\n    prevTextureRef.current = texture;\n    return texture;\n  }, [isInitialised, color, size, app]);\n\n  const noise2D = useMemo(() => createNoise2D(randomFn), [randomFn]);\n\n  const points = useMemo(() => {\n    if (!isInitialised) return [];\n\n    const effectiveW = app.renderer?.width;\n    const effectiveH = app.renderer?.height;\n\n    if (!effectiveW || !effectiveH) return [];\n\n    const cols = Math.ceil(effectiveW / cellSize);\n    const rows = Math.ceil(effectiveH / cellSize);\n    let hSpacing = cellSize;\n    let vSpacing = cellSize;\n    const offsetX = size / 2;\n    const offsetY = size / 2;\n\n    if (fitToContainer) {\n      hSpacing = (effectiveW - size) / cols;\n      vSpacing = (effectiveH - size) / rows;\n    }\n\n    const arr = [];\n    const phaseOffset = Math.PI * 2;\n    const baseSpeed = minSpeed + (maxSpeed - minSpeed) / 2;\n    const halfW = effectiveW / 2;\n    const halfH = effectiveH / 2;\n\n    for (let c = 0; c <= cols; c++) {\n      for (let r = 0; r <= rows; r++) {\n        const nx = c / cols;\n        const ny = r / rows;\n        const noiseVal = noise2D(nx * frequency, ny * frequency);\n        if (noiseVal < threshold) continue;\n\n        const point = {\n          x: c * hSpacing + offsetX,\n          y: r * vSpacing + offsetY,\n          id: `${c}-${r}`,\n        };\n\n        if (ellipseMask) {\n          const translatedPoint = {\n            x: point.x - halfW,\n            y: point.y - halfH,\n          };\n          const isInside =\n            (translatedPoint.x / ellipseMask.radiusX) ** 2 +\n              (translatedPoint.y / ellipseMask.radiusY) ** 2 <=\n            1;\n\n          if (isInside === ellipseMask.invert) {\n            continue;\n          }\n        }\n\n        const speed =\n          mode === \"random\"\n            ? minSpeed + (maxSpeed - minSpeed) * Math.random()\n            : baseSpeed;\n\n        let phase: number;\n        let normalized = 0;\n        if (mode === \"random\") {\n          phase = Math.random() * Math.PI * 2;\n        } else if (mode === \"top-to-bottom\") {\n          normalized = point.y / effectiveH;\n          phase = (1 - normalized) * phaseOffset;\n        } else if (mode === \"bottom-to-top\") {\n          normalized = point.y / effectiveH;\n          phase = normalized * phaseOffset;\n        } else if (mode === \"left-to-right\") {\n          normalized = point.x / effectiveW;\n          phase = (1 - normalized) * phaseOffset;\n        } else if (mode === \"right-to-left\") {\n          normalized = point.x / effectiveW;\n          phase = normalized * phaseOffset;\n        } else if (mode === \"center-outward\") {\n          const cx = effectiveW / 2;\n          const cy = effectiveH / 2;\n          const dist = Math.sqrt((point.x - cx) ** 2 + (point.y - cy) ** 2);\n          const maxDist = Math.sqrt(cx ** 2 + cy ** 2);\n          normalized = dist / maxDist;\n          phase = (1 - normalized) * phaseOffset;\n        } else {\n          phase = Math.random() * Math.PI * 2;\n        }\n\n        arr.push({ ...point, phase, speed, ref: null as Sprite | null });\n      }\n    }\n    return arr;\n  }, [\n    cellSize,\n    minSpeed,\n    maxSpeed,\n    isInitialised,\n    noise2D,\n    frequency,\n    threshold,\n    app,\n    size,\n    fitToContainer,\n    mode,\n    ellipseMask,\n  ]);\n\n  const animate = useCallback<TickerCallback<unknown>>(\n    (ticker) => {\n      timeRef.current += ticker.deltaMS;\n      const time = timeRef.current;\n\n      points.forEach((point) => {\n        if (point.ref) {\n          const alpha =\n            minAlpha +\n            maxAlpha * (Math.sin(time * point.speed + point.phase) * 0.5 + 0.5);\n          point.ref.alpha = alpha;\n        }\n      });\n    },\n    [points, minAlpha, maxAlpha],\n  );\n\n  useTick(animate);\n\n  if (!isInitialised || !dotTexture) return null;\n\n  return (\n    <pixiContainer ref={containerRef}>\n      {points.map((point) => {\n        const initialAlpha =\n          minAlpha + maxAlpha * (Math.sin(point.phase) * 0.5 + 0.5);\n        return (\n          <pixiSprite\n            ref={(el) => {\n              point.ref = el;\n            }}\n            key={point.id}\n            texture={dotTexture}\n            x={point.x}\n            y={point.y}\n            anchor={0.5}\n            tint={color}\n            alpha={initialAlpha}\n          />\n        );\n      })}\n    </pixiContainer>\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}