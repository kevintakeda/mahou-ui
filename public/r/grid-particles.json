{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "grid-particles",
  "type": "registry:ui",
  "dependencies": [
    "pixi.js",
    "@pixi/react",
    "simplex-noise"
  ],
  "files": [
    {
      "path": "src/registry/default/ui/grid-particles.tsx",
      "content": "\"use client\";\n\nimport { useApplication, useExtend, useTick } from \"@pixi/react\";\nimport {\n  Container,\n  Graphics,\n  Sprite,\n  type Texture,\n  type TickerCallback,\n} from \"pixi.js\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { createNoise2D } from \"simplex-noise\";\n\nexport interface RectDefinition {\n  type: \"rect\";\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface PolygonDefinition {\n  type: \"polygon\";\n  points: Array<{ x: number; y: number }>;\n}\n\nexport type ShapeDefinition = RectDefinition | PolygonDefinition;\n\nexport interface GridParticlesProps {\n  cellSize?: number;\n  minAlpha?: number;\n  maxAlpha?: number;\n  color?: number;\n  minSpeed?: number;\n  maxSpeed?: number;\n  size?: number;\n  frequency?: number;\n  threshold?: number;\n  masks?: ShapeDefinition[];\n  fitToContainer?: boolean;\n  mode?:\n    | \"random\"\n    | \"top-to-bottom\"\n    | \"bottom-to-top\"\n    | \"left-to-right\"\n    | \"right-to-left\"\n    | \"center-outward\";\n  randomFn?: () => number;\n}\n\nfunction pointInRect(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  rw: number,\n  rh: number,\n): boolean {\n  return x >= rx && x <= rx + rw && y >= ry && y <= ry + rh;\n}\n\nfunction pointInPolygon(\n  x: number,\n  y: number,\n  polygon: Array<{ x: number; y: number }>,\n): boolean {\n  const n = polygon.length;\n  let isInside = false;\n\n  for (let i = 0, j = n - 1; i < n; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    const intersect =\n      yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) isInside = !isInside;\n  }\n\n  return isInside;\n}\n\nfunction isPointInShapes(\n  point: { x: number; y: number },\n  shapes: ShapeDefinition[],\n): boolean {\n  if (!shapes || shapes.length === 0) return true;\n\n  return shapes.some((shape) => {\n    if (shape.type === \"rect\") {\n      return pointInRect(\n        point.x,\n        point.y,\n        shape.x,\n        shape.y,\n        shape.width,\n        shape.height,\n      );\n    } else if (shape.type === \"polygon\") {\n      return pointInPolygon(point.x, point.y, shape.points);\n    }\n    return false;\n  });\n}\n\nexport function GridParticles({\n  cellSize = 24,\n  minAlpha = 0,\n  maxAlpha = 1,\n  color = 0xd2ff65,\n  minSpeed = 0.001,\n  maxSpeed = 0.002,\n  size = 2,\n  frequency = 3,\n  threshold = 0.4,\n  masks = [],\n  fitToContainer = true,\n  mode = \"random\",\n  randomFn = Math.random,\n}: GridParticlesProps) {\n  useExtend({ Container, Sprite, Graphics });\n  const { app, isInitialised } = useApplication();\n  const timeRef = useRef(0);\n  const containerRef = useRef<Container>(null);\n  const prevTextureRef = useRef<Texture>(null);\n\n  const dotTexture = useMemo(() => {\n    if (!isInitialised) return null;\n    const g = new Graphics();\n    g.rect(0, 0, size, size).fill({ color });\n    if (prevTextureRef.current != null) {\n      prevTextureRef.current.destroy();\n    }\n    const texture = app.renderer.generateTexture(g);\n    prevTextureRef.current = texture;\n    return texture;\n  }, [isInitialised, color, size, app]);\n\n  const noise2D = useMemo(() => createNoise2D(randomFn), [randomFn]);\n\n  const points = useMemo(() => {\n    if (!isInitialised) return [];\n\n    const effectiveW = app.renderer.width;\n    const effectiveH = app.renderer.height;\n\n    if (!effectiveW || !effectiveH) return [];\n\n    const cols = Math.ceil(effectiveW / cellSize);\n    const rows = Math.ceil(effectiveH / cellSize);\n    let hSpacing = cellSize;\n    let vSpacing = cellSize;\n    const offsetX = size / 2;\n    const offsetY = size / 2;\n\n    if (fitToContainer) {\n      hSpacing = (effectiveW - size) / cols;\n      vSpacing = (effectiveH - size) / rows;\n    }\n\n    const arr = [];\n    const phaseOffset = Math.PI * 2;\n    const baseSpeed = minSpeed + (maxSpeed - minSpeed) / 2;\n\n    for (let c = 0; c <= cols; c++) {\n      for (let r = 0; r <= rows; r++) {\n        const nx = c / cols;\n        const ny = r / rows;\n        const noiseVal = noise2D(nx * frequency, ny * frequency);\n        if (noiseVal < threshold) continue;\n\n        const point = {\n          x: c * hSpacing + offsetX,\n          y: r * vSpacing + offsetY,\n          id: `${c}-${r}`,\n        };\n\n        const speed =\n          mode === \"random\"\n            ? minSpeed + (maxSpeed - minSpeed) * Math.random()\n            : baseSpeed;\n\n        let phase: number;\n        let normalized = 0;\n        if (mode === \"random\") {\n          phase = Math.random() * Math.PI * 2;\n        } else if (mode === \"top-to-bottom\") {\n          normalized = point.y / effectiveH;\n          phase = (1 - normalized) * phaseOffset;\n        } else if (mode === \"bottom-to-top\") {\n          normalized = point.y / effectiveH;\n          phase = normalized * phaseOffset;\n        } else if (mode === \"left-to-right\") {\n          normalized = point.x / effectiveW;\n          phase = (1 - normalized) * phaseOffset;\n        } else if (mode === \"right-to-left\") {\n          normalized = point.x / effectiveW;\n          phase = normalized * phaseOffset;\n        } else if (mode === \"center-outward\") {\n          const cx = effectiveW / 2;\n          const cy = effectiveH / 2;\n          const dist = Math.sqrt((point.x - cx) ** 2 + (point.y - cy) ** 2);\n          const maxDist = Math.sqrt(cx ** 2 + cy ** 2);\n          normalized = dist / maxDist;\n          phase = (1 - normalized) * phaseOffset;\n        } else {\n          phase = Math.random() * Math.PI * 2;\n        }\n        if (isPointInShapes(point, masks)) {\n          arr.push({ ...point, phase, speed, ref: null as Sprite | null });\n        }\n      }\n    }\n    return arr;\n  }, [\n    cellSize,\n    minSpeed,\n    maxSpeed,\n    isInitialised,\n    noise2D,\n    frequency,\n    threshold,\n    masks,\n    app,\n    app.renderer?.width,\n    app.renderer?.height,\n    size,\n    fitToContainer,\n    mode,\n  ]);\n\n  const animate = useCallback<TickerCallback<unknown>>(\n    (ticker) => {\n      timeRef.current += ticker.deltaTime;\n      const time = timeRef.current;\n\n      points.forEach((point) => {\n        if (point.ref) {\n          const alpha =\n            minAlpha +\n            maxAlpha * (Math.sin(time * point.speed + point.phase) * 0.5 + 0.5);\n          point.ref.alpha = alpha;\n        }\n      });\n    },\n    [points, minAlpha, maxAlpha],\n  );\n\n  useTick(animate);\n\n  if (!isInitialised || !dotTexture) return null;\n\n  return (\n    <pixiContainer ref={containerRef}>\n      {points.map((point) => {\n        const initialAlpha =\n          minAlpha + maxAlpha * (Math.sin(point.phase) * 0.5 + 0.5);\n        return (\n          <pixiSprite\n            ref={(el) => {\n              point.ref = el;\n            }}\n            key={point.id}\n            texture={dotTexture}\n            x={point.x}\n            y={point.y}\n            anchor={0.5}\n            tint={color}\n            alpha={initialAlpha}\n          />\n        );\n      })}\n    </pixiContainer>\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}