{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stream",
  "type": "registry:ui",
  "files": [
    {
      "path": "src/registry/default/ui/stream.tsx",
      "content": "import { type SVGProps, useEffect, useRef, useState } from \"react\";\n\ninterface StreamProps extends SVGProps<SVGPathElement> {\n  containerRef: React.RefObject<HTMLElement | null>;\n  fromRef: React.RefObject<HTMLElement | null>;\n  toRef: React.RefObject<HTMLElement | null>;\n  curvature?: number;\n  endYOffset?: number;\n  startYOffset?: number;\n  borderRadius?: number;\n  offset?: number;\n  stepPosition?: number;\n}\n\nenum Position {\n  Top = \"top\",\n  Bottom = \"bottom\",\n  Left = \"left\",\n  Right = \"right\",\n}\n\nfunction getRoundedPath(\n  points: Array<[number, number]>,\n  radius: number,\n): string {\n  if (points.length < 3) {\n    return (\n      `M${points[0][0]},${points[0][1]}` +\n      points\n        .slice(1)\n        .map((p) => `L${p[0]},${p[1]}`)\n        .join(\"\")\n    );\n  }\n\n  let d = `M${points[0][0]},${points[0][1]}`;\n\n  for (let i = 1; i < points.length - 1; i++) {\n    const p0 = points[i - 1];\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const v1 = [p0[0] - p1[0], p0[1] - p1[1]];\n    const v2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const len1 = Math.sqrt(v1[0] ** 2 + v1[1] ** 2);\n    const len2 = Math.sqrt(v2[0] ** 2 + v2[1] ** 2);\n\n    const dot = v1[0] * v2[0] + v1[1] * v2[1];\n    const angle = Math.acos(Math.max(-1, Math.min(1, dot / (len1 * len2))));\n\n    let tan = radius / Math.tan(angle / 2);\n    tan = Math.min(tan, len1 / 2, len2 / 2);\n\n    const r = tan * Math.tan(angle / 2);\n    const t1 = [p1[0] + (tan * v1[0]) / len1, p1[1] + (tan * v1[1]) / len1];\n    const t2 = [p1[0] + (tan * v2[0]) / len2, p1[1] + (tan * v2[1]) / len2];\n\n    const sweepFlag = v1[0] * v2[1] - v1[1] * v2[0] > 0 ? 0 : 1;\n\n    d += `L${t1[0].toFixed(3)},${t1[1].toFixed(3)}`;\n    d += `A${r.toFixed(3)},${r.toFixed(3)},0,0,${sweepFlag},${t2[0].toFixed(3)},${t2[1].toFixed(3)}`;\n  }\n\n  const last = points[points.length - 1];\n  d += `L${last[0]},${last[1]}`;\n\n  return d;\n}\n\nfunction getStepPath({\n  sourceX,\n  sourceY,\n  sourcePosition = Position.Bottom,\n  targetX,\n  targetY,\n  targetPosition = Position.Top,\n  borderRadius = 5,\n  offset = 20,\n  stepPosition = 0.5,\n}: {\n  sourceX: number;\n  sourceY: number;\n  sourcePosition?: Position;\n  targetX: number;\n  targetY: number;\n  targetPosition?: Position;\n  borderRadius?: number;\n  offset?: number;\n  stepPosition?: number;\n}): string {\n  let startX = sourceX;\n  let startY = sourceY;\n\n  if (sourcePosition === Position.Bottom) startY += offset;\n  else if (sourcePosition === Position.Top) startY -= offset;\n  else if (sourcePosition === Position.Left) startX -= offset;\n  else if (sourcePosition === Position.Right) startX += offset;\n\n  let endX = targetX;\n  let endY = targetY;\n\n  if (targetPosition === Position.Bottom) endY += offset;\n  else if (targetPosition === Position.Top) endY -= offset;\n  else if (targetPosition === Position.Left) endX -= offset;\n  else if (targetPosition === Position.Right) endX += offset;\n\n  const midX = sourceX + (targetX - sourceX) * stepPosition;\n  const midY = sourceY + (targetY - sourceY) * stepPosition;\n\n  const points: Array<[number, number]> = [[sourceX, sourceY]];\n\n  if (sourcePosition === Position.Bottom || sourcePosition === Position.Top) {\n    points.push([sourceX, startY]);\n    points.push([midX, startY]);\n    points.push([midX, endY]);\n  } else {\n    points.push([startX, sourceY]);\n    points.push([startX, midY]);\n    points.push([endX, midY]);\n  }\n\n  points.push([targetX, targetY]);\n\n  return getRoundedPath(points, borderRadius);\n}\n\nexport function Stream({\n  containerRef,\n  fromRef,\n  toRef,\n  curvature = -75,\n  endYOffset = 0,\n  startYOffset = 0,\n  borderRadius = 5,\n  offset = 20,\n  stepPosition = 0.5,\n  ...pathProps\n}: StreamProps) {\n  const [pathD, setPathD] = useState<string>(\"\");\n  const svgRef = useRef<SVGSVGElement>(null);\n\n  useEffect(() => {\n    const updatePath = () => {\n      if (\n        !containerRef.current ||\n        !fromRef.current ||\n        !toRef.current ||\n        !svgRef.current\n      ) {\n        return;\n      }\n\n      const container = containerRef.current.getBoundingClientRect();\n      const fromEl = fromRef.current.getBoundingClientRect();\n      const toEl = toRef.current.getBoundingClientRect();\n\n      // Calculate positions relative to container\n      const sourceX = fromEl.left - container.left + fromEl.width / 2;\n      const sourceY =\n        fromEl.top - container.top + fromEl.height / 2 + startYOffset;\n\n      const targetX = toEl.left - container.left + toEl.width / 2;\n      const targetY = toEl.top - container.top + toEl.height / 2 + endYOffset;\n\n      // Generate path\n      const d = getStepPath({\n        sourceX,\n        sourceY,\n        sourcePosition: Position.Bottom,\n        targetX,\n        targetY,\n        targetPosition: Position.Top,\n        borderRadius,\n        offset,\n        stepPosition,\n      });\n\n      setPathD(d);\n\n      // Update SVG dimensions to contain the path\n      const padding = 50;\n      const minX = Math.min(sourceX, targetX) - padding;\n      const minY = Math.min(sourceY, targetY) - padding;\n      const maxX = Math.max(sourceX, targetX) + padding;\n      const maxY = Math.max(sourceY, targetY) + padding;\n\n      svgRef.current.setAttribute(\n        \"viewBox\",\n        `${minX} ${minY} ${maxX - minX} ${maxY - minY}`,\n      );\n      svgRef.current.style.width = \"100%\";\n      svgRef.current.style.height = \"100%\";\n    };\n\n    updatePath();\n\n    window.addEventListener(\"resize\", updatePath);\n    const resizeObserver = new ResizeObserver(updatePath);\n\n    if (containerRef.current) resizeObserver.observe(containerRef.current);\n    if (fromRef.current) resizeObserver.observe(fromRef.current);\n    if (toRef.current) resizeObserver.observe(toRef.current);\n\n    return () => {\n      window.removeEventListener(\"resize\", updatePath);\n      resizeObserver.disconnect();\n    };\n  }, [\n    containerRef,\n    fromRef,\n    toRef,\n    startYOffset,\n    endYOffset,\n    borderRadius,\n    offset,\n    stepPosition,\n  ]);\n\n  return (\n    // biome-ignore lint/a11y/noSvgWithoutTitle: this is decorative\n    <svg\n      ref={svgRef}\n      className=\"pointer-events-none absolute inset-0 overflow-visible\"\n    >\n      <path\n        d={pathD}\n        stroke=\"currentColor\"\n        strokeWidth={2}\n        fill=\"none\"\n        {...pathProps}\n      />\n    </svg>\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}