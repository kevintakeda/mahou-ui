{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "stream",
  "type": "registry:ui",
  "files": [
    {
      "path": "src/registry/default/ui/stream.tsx",
      "content": "\"use client\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nexport function Stream({\n  radius = 16,\n  points,\n  animationDuration = 3,\n  className,\n  width = 600,\n  height = 600,\n}: {\n  stroke?: string;\n  radius?: number;\n  points: Array<[number, number]>;\n  animationDuration?: number;\n  direction?: number;\n  gradientColors?: [string, string];\n  className?: string;\n  height?: number;\n  width?: number;\n}) {\n  const d = useMemo(() => getRoundedPath(points, radius), [points, radius]);\n  const svg = useMemo(\n    () =>\n      `url(\"data:image/svg+xml,${encodeURIComponent(\n        `<svg viewBox='0 0 ${width} ${height}' xmlns='http://www.w3.org/2000/svg' preserveAspectRatio=\"none\"><path d='${d}' fill='none' stroke='#ffffff' stroke-width='${1}px' shape-rendering='optimizeQuality' /></svg>`,\n      )}\")`,\n    [d, width, height],\n  );\n  const animationRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const element = animationRef.current;\n    if (!element) return;\n    const animation = element.animate(\n      [{ transform: \"translateY(-100%)\" }, { transform: \"translateY(100%)\" }],\n      {\n        duration: animationDuration * 1000,\n        iterations: Infinity,\n        easing: \"linear\",\n      },\n    );\n    return () => {\n      animation.cancel();\n    };\n  }, [animationDuration]);\n\n  return (\n    <div\n      style={{\n        maskImage: svg,\n      }}\n      className={className}\n    >\n      <div\n        ref={animationRef}\n        className=\"h-full w-full\"\n        style={{\n          background: `linear-gradient(to bottom, transparent, white, transparent)`,\n        }}\n      />\n    </div>\n  );\n}\n\nfunction getRoundedPath(points: Array<[number, number]>, radius: number) {\n  if (points.length < 3) {\n    return (\n      `M${points[0][0]},${points[0][1]}` +\n      points\n        .slice(1)\n        .map((p) => `L${p[0]},${p[1]}`)\n        .join(\"\")\n    );\n  }\n  let d = `M${points[0][0]},${points[0][1]}`;\n\n  for (let i = 1; i < points.length - 1; i++) {\n    const p0 = points[i - 1];\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const v1 = [p0[0] - p1[0], p0[1] - p1[1]];\n    const v2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const len1 = Math.sqrt(v1[0] ** 2 + v1[1] ** 2);\n    const len2 = Math.sqrt(v2[0] ** 2 + v2[1] ** 2);\n\n    const dot = v1[0] * v2[0] + v1[1] * v2[1];\n    const angle = Math.acos(Math.max(-1, Math.min(1, dot / (len1 * len2))));\n\n    let tan = radius / Math.tan(angle / 2);\n    tan = Math.min(tan, len1 / 2, len2 / 2);\n\n    const r = tan * Math.tan(angle / 2);\n    const t1 = [p1[0] + (tan * v1[0]) / len1, p1[1] + (tan * v1[1]) / len1];\n    const t2 = [p1[0] + (tan * v2[0]) / len2, p1[1] + (tan * v2[1]) / len2];\n\n    const sweepFlag = v1[0] * v2[1] - v1[1] * v2[0] > 0 ? 0 : 1;\n\n    d += `L${t1[0].toFixed(3)},${t1[1].toFixed(3)}`;\n    d += `A${r.toFixed(3)},${r.toFixed(3)},0,0,${sweepFlag},${t2[0].toFixed(3)},${t2[1].toFixed(3)}`;\n  }\n\n  const last = points[points.length - 1];\n  d += `L${last[0]},${last[1]}`;\n\n  return d;\n}\n",
      "type": "registry:ui"
    }
  ]
}