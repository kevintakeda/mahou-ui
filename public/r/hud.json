{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hud",
  "type": "registry:ui",
  "files": [
    {
      "path": "src/registry/default/ui/hud.tsx",
      "content": "\"use client\";\n\nimport { Application, useApplication, useExtend, useTick } from \"@pixi/react\";\nimport { Container, Graphics, Sprite, type TickerCallback } from \"pixi.js\";\nimport {\n  type PropsWithChildren,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { createRoundedPath } from \"../utils/createRoundedPath\";\n\ninterface HUDProps {\n  className?: string;\n}\n\nexport function HUD({ children, className }: PropsWithChildren<HUDProps>) {\n  const parentRef = useRef(null);\n\n  return (\n    <div ref={parentRef} className={className}>\n      <Application\n        resizeTo={parentRef}\n        autoStart\n        sharedTicker\n        preference=\"webgpu\"\n        backgroundAlpha={0}\n      >\n        {children}\n      </Application>\n    </div>\n  );\n}\n\ninterface DotGridProps {\n  cols?: number;\n  rows?: number;\n  minAlpha?: number;\n  maxAlpha?: number;\n  color?: number;\n  maxSpeed?: number;\n  radius?: number;\n  width?: number;\n  height?: number;\n}\n\nexport function HUDDotGrid({\n  cols = 4,\n  rows = 4,\n  minAlpha = 0,\n  maxAlpha = 0.3,\n  color = 0xffffff,\n  maxSpeed = 0.005,\n  radius = 1,\n  width,\n  height,\n}: DotGridProps) {\n  useExtend({ Container, Sprite });\n\n  const { app, isInitialised } = useApplication();\n  const [time, setTime] = useState(0);\n\n  // Create dot texture once\n  const dotTexture = useMemo(() => {\n    if (!isInitialised || !app) return null;\n\n    const g = new Graphics();\n    g.circle(0, 0, radius).fill({ color: color });\n    return app.renderer.generateTexture(g);\n  }, [isInitialised, color, radius, app]);\n\n  // Compute all intersection positions once\n  const points = useMemo(() => {\n    if (!isInitialised || !app) return [];\n\n    const effectiveW = width ?? app.canvas.width;\n    const effectiveH = height ?? app.canvas.height;\n\n    const cellWidth = effectiveW / cols;\n    const cellHeight = effectiveH / rows;\n    const arr = [];\n    for (let c = 0; c <= cols; c++) {\n      for (let r = 0; r <= rows; r++) {\n        arr.push({\n          x: c * cellWidth,\n          y: r * cellHeight,\n          phase: Math.random() * Math.PI * 2,\n          speed: maxSpeed * Math.random(),\n          id: `${c}-${r}`,\n        });\n      }\n    }\n    return arr;\n  }, [cols, rows, maxSpeed, isInitialised, app, width, height]);\n\n  const animate = useCallback<TickerCallback<unknown>>(\n    (delta) => setTime((t) => t + delta.elapsedMS),\n    [],\n  );\n\n  useTick(animate);\n\n  if (!isInitialised || !app || !dotTexture) return null;\n\n  return (\n    <pixiContainer>\n      {points.map((point) => {\n        const alpha =\n          minAlpha +\n          maxAlpha * (Math.sin(time * point.speed + point.phase) * 0.5 + 0.5);\n        return (\n          <pixiSprite\n            key={point.id}\n            texture={dotTexture}\n            x={point.x}\n            y={point.y}\n            anchor={0.5}\n            alpha={alpha}\n          />\n        );\n      })}\n    </pixiContainer>\n  );\n}\n\nexport function HUDLineGrid({\n  cols = 4,\n  rows = 3,\n  color = 0x888888,\n  alpha = 0.1,\n}) {\n  useExtend({ Graphics });\n\n  const { app, isInitialised } = useApplication();\n\n  if (!isInitialised || !app) return null;\n  return (\n    <pixiGraphics\n      width={app.canvas.width}\n      height={app.canvas.height}\n      draw={(g) => {\n        g.clear();\n        const { width, height } = app.canvas;\n        const cellWidth = width / cols;\n        const cellHeight = height / rows;\n        const offset = 1;\n\n        // Vertical lines\n        for (let c = 0; c <= cols; c++) {\n          const x = Math.round(c * cellWidth) + offset;\n          g.moveTo(x, 0);\n          g.lineTo(x, height);\n        }\n\n        // Horizontal lines\n        for (let r = 0; r <= rows; r++) {\n          const y = Math.round(r * cellHeight) + offset;\n          g.moveTo(0, y);\n          g.lineTo(width, y);\n        }\n\n        // Border\n        g.rect(offset, offset, width - 1, height - 1);\n        g.stroke({ width: 1, color: 0x888888, alpha: 0.1, pixelLine: true });\n      }}\n    />\n  );\n}\n\nexport function HUDLine({ color = 0x888888, alpha = 0.1 }) {\n  useExtend({ Graphics });\n\n  const { app, isInitialised } = useApplication();\n\n  if (!isInitialised || !app) return null;\n  return (\n    <pixiGraphics\n      width={app.canvas.width}\n      height={app.canvas.height}\n      draw={(g) => {\n        g.clear();\n        g.svg(\n          createRoundedPath(\n            [\n              { x: 0, y: 200 },\n              { x: 400, y: 200 },\n              { x: 400, y: 600 },\n            ],\n            10,\n          ),\n        );\n      }}\n    />\n  );\n}\n",
      "type": "registry:ui"
    }
  ]
}